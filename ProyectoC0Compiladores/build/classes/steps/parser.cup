package steps;

import java_cup.runtime.*;
import ui.IDE;
import structures.*;
import java.util.ArrayList;

parser code {:

    public void syntax_error(java_cup.runtime.Symbol s){
        IDE.error = true;
        IDE.errMessage = IDE.errMessage +("Compiler has detected a syntax error at line " + (s.left+1) 
            + " column " + s.right + " symbol " + s.value);
    }
    public void report_fatal_error(String message, Object info) {
        IDE.error = true;
        IDE.errMessage = IDE.errMessage +("Fatal Error! Your code is about to explode");
    }
:};

action code {:
    Table table;
    int inWhile;
    int direction;
    int countIf;
    int countLoop;
    int countConstant;
    IntermediateCode file;
    Stack ifStack;
    Stack loopStack;
    ArrayList<String> constantList;

    void init(){
        table = new Table();
        inWhile = 0;
        direction = 30000;
        countIf = 0;
        countLoop = 0;
        countConstant = 0;
        ifStack = new Stack();
        loopStack = new Stack();
        constantList = new ArrayList<>();
        
        file = new IntermediateCode("test.txt");
        file.openFile();
    }
    boolean exists(String symbol){
        return table.ContainedInSymbolTable(symbol);
    }
    void addNewSymbol(int code, String symbol){
        table.addNewSymbol(code, symbol, direction);
        direction++;
    }
    Expression binaryOp(String op, Expression e1, Expression e2){
        file.write(new IntermediateLine(op,String.valueOf(e1.getDirection()),String.valueOf(e2.getDirection()),String.valueOf(direction)));
        return new Expression(direction++);
    }
    Expression unaryOp(String op, String e1){
        file.write(new IntermediateLine(op,e1,"null",String.valueOf(direction)));
        return new Expression(direction++);
    }
    
    void asignValue(String id, Expression e){
        file.write(new IntermediateLine("LOAD_DIRECTION", String.valueOf(e.getDirection()), "null",String.valueOf(table.getSymbolDirection(id))));      
    }

    void closeFile(){
        file.close();
    }
    void condition(Expression e, int number){
        file.write(new IntermediateLine("JUMP_CONDITION", String.valueOf(e.getDirection()), "null","ELSE_"+String.valueOf(number)));
    }
    void condition2(Expression e, int number) {
        file.write(new IntermediateLine("JUMP_CONDITION", String.valueOf(e.getDirection()), "null","LOOPEND_"+String.valueOf(number)));
    }
    void jumpLabel(String label, int number){
        file.write(new IntermediateLine("JUMP_LABEL", "null", "null", label+"_"+String.valueOf(number)));
    }
    void setLabel(String label, int number){
        file.write(new IntermediateLine("LABEL", "null", "null", label+"_"+String.valueOf(number)));
    }
    void printW(Expression e){
        file.write(new IntermediateLine("PRINT_INT", String.valueOf(e.getDirection()), "null", "null"));        
    }
    void printS(String c, int number){
        constantList.add(c);
        file.write(new IntermediateLine("PRINT_CONSTANT", "CONSTANT_"+String.valueOf(number), "null", "null"));        
    }
    void generateConstants() {
        for(int i=0; i<constantList.size(); i++){
            file.write(new IntermediateLine("PUT_CONSTANT", "CONSTANT_"+String.valueOf(i+1), "null", constantList.get(i)));          
        }
    }
    void programEnd(){
            file.write(new IntermediateLine("END", "null", "null", "null"));          
    }

:}

/* Terminals and Non Terminals */ 

terminal            PLUS, MINUS, TIMES, DIVIDE; 
terminal            MORE, LESS, EQUAL, NOTEQUAL;
terminal            AND, OR, ASIGN;
terminal            LPAR, RPAR, SEMICOLON, RKEY, LKEY;
terminal            CONSTANT;
terminal            IDENTIFIER;
terminal            MAIN, IF, WHILE, PUTS, PUTW, INT, BREAK, ELSE;
terminal Integer    NUMBER;
terminal Boolean    BOOLEAN;

non terminal        program;
non terminal        body;
non terminal        varlist;
non terminal        var;
non terminal        stmtlist;
non terminal        stmt;
non terminal        ifstmt;
non terminal        whilestmt;
non terminal        asignstmt;
non terminal        putwstmt;
non terminal        putsstmt;
non terminal        breakstmt;
non terminal Expression      cond;
non terminal Expression      ope;
non terminal        stmts;
non terminal        elsestmt;
non terminal        bodylist;

/* Precedence */ 

precedence left     ASIGN; 
precedence left     AND, OR;
precedence left     EQUAL, NOTEQUAL;
precedence left     MORE, LESS; 
precedence left     PLUS, MINUS; 
precedence left     TIMES, DIVIDE;
precedence left     LPAR, RPAR; 
precedence left     ELSE; 


/* Grammar Rules */ 

program ::= {:init();:}
            varlist bodylist
            | bodylist
            ;

bodylist ::= bodylist body
            | body;

body    ::= MAIN LPAR RPAR LKEY stmtlist 
                {:
                    programEnd();
                    generateConstants();
                    closeFile();
                :}
            RKEY
            ;

varlist ::= varlist var
            | var
            ;

var     ::= INT IDENTIFIER:id SEMICOLON              {: if(!exists(id.toString())){
                                                            addNewSymbol(sym.INT, id.toString());
                                                        }else{
                                                            IDE.error = true;
                                                            IDE.errMessage = IDE.errMessage +(ErrorMessage.VARIABLEEXISTS+id.toString());}:}
            ;

stmtlist::= stmts
            | ;

stmts   ::= stmts stmt | stmt;

stmt    ::= ifstmt
            | whilestmt
            | asignstmt
            | putwstmt
            | putsstmt
            | breakstmt                              {:if(inWhile==0){IDE.error = true;IDE.errMessage = IDE.errMessage +(ErrorMessage.BREAKERROR);}:}
            ;

ifstmt      ::= IF LPAR
                    {:
                        countIf++;ifStack.push(countIf);
                    :} 
                cond:c 
                    {:
                        condition(c, ifStack.top());
                    :} 
                RPAR LKEY stmtlist RKEY 
                    {:
                        jumpLabel("ENDIF", ifStack.top());
                        setLabel("ELSE", ifStack.top());
                    :} 
                elsestmt 
                    {:
                        setLabel("ENDIF", ifStack.top());
                        ifStack.pop();
                    :}
                ;

elsestmt    ::= ELSE LKEY stmtlist RKEY
                | ;

whilestmt   ::= WHILE LPAR
                    {:
                        countLoop++;
                        loopStack.push(countLoop);
                        setLabel("LOOP", loopStack.top());
                    :}
                cond:c
                    {:
                        condition2(c, loopStack.top());
                    :} 
                RPAR LKEY
                    {:
                        inWhile++;
                    :} 
                stmtlist 
                    {:
                        inWhile--;
                    :} 
                RKEY
                    {:
                        jumpLabel("LOOP", loopStack.top());
                        setLabel("LOOPEND", loopStack.top());
                        loopStack.pop();
                    :}
                ;

asignstmt   ::= IDENTIFIER:id 
                    {:
                        if(!exists(id.toString())){
                            IDE.error = true;
                            IDE.errMessage = IDE.errMessage +(ErrorMessage.NOVARIABLE+id.toString());
                        }
                    :}
                ASIGN ope:e SEMICOLON 
                    {:
                        asignValue(id.toString(), e);
                    :}
                ;

putwstmt    ::= PUTW LPAR ope:e
                    {:
                        printW(e);
                    :} 
                RPAR SEMICOLON
                ;

putsstmt    ::= PUTS LPAR CONSTANT:c
                    {:
                        countConstant++;
                        printS(c.toString(), countConstant);
                    :} 
                RPAR SEMICOLON
                ;

breakstmt   ::= BREAK SEMICOLON
                ;

ope     ::= ope:e1 PLUS  ope:e2                         {:RESULT=binaryOp("PLUS",e1,e2);:}                            
            | ope:e1 MINUS ope:e2                       {:RESULT=binaryOp("MINUS",e1,e2);:}                       
            | ope:e1 TIMES ope:e2                       {:RESULT=binaryOp("TIMES",e1,e2);:}                        
            | ope:e1 DIVIDE ope:e2                      {:RESULT=binaryOp("DIVIDE",e1,e2);:}                       
            | MINUS ope:e                               {://RESULT=minus(e);:}                       
            | NUMBER:n                                  {:RESULT=unaryOp("LOAD_NUMBER",n.toString());:}                     
            | IDENTIFIER:id                             {:if(!exists(id.toString())){
                                                            IDE.error = true;IDE.errMessage = IDE.errMessage +(ErrorMessage.NOVARIABLE+id.toString());RESULT=unaryOp("LOAD_DIRECTION",null);
                                                          }else{RESULT=unaryOp("LOAD_DIRECTION",id.toString());}
                                                           :}             
            | LPAR ope:e RPAR                           {:RESULT=e;:}                          
            ;

cond    ::= cond:e1 AND cond:e2                         {:RESULT=binaryOp("AND",e1,e2);:}                     
            | cond:e1 OR cond:e2                        {:RESULT=binaryOp("OR",e1,e2);:}                    
            | ope:e1 EQUAL ope:e2                       {:RESULT=binaryOp("EQUAL",e1,e2);:}                     
            | ope:e1 NOTEQUAL ope:e2                    {:RESULT=binaryOp("NOTEQUAL",e1,e2);:}                     
            | ope:e1 MORE ope:e2                        {:RESULT=binaryOp("MORE",e1,e2);:}               
            | ope:e1 LESS ope:e2                        {:RESULT=binaryOp("LESS",e1,e2);:}                                
            | LPAR cond:e RPAR                          {:RESULT=e;:}
            ;